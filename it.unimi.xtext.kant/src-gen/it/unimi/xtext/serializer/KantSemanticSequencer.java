/*
 * generated by Xtext 2.29.0
 */
package it.unimi.xtext.serializer;

import com.google.inject.Inject;
import it.unimi.xtext.kant.AuthenticationCheck;
import it.unimi.xtext.kant.Communication;
import it.unimi.xtext.kant.EqualityCheck;
import it.unimi.xtext.kant.FreshnessCheck;
import it.unimi.xtext.kant.FunctionDef;
import it.unimi.xtext.kant.FunctionInversionDef;
import it.unimi.xtext.kant.FunctionKey;
import it.unimi.xtext.kant.FunctionKeyElement;
import it.unimi.xtext.kant.FunctionParam;
import it.unimi.xtext.kant.FunctionReturn;
import it.unimi.xtext.kant.FunctionReturnElement;
import it.unimi.xtext.kant.KantPackage;
import it.unimi.xtext.kant.KnowledgeBase;
import it.unimi.xtext.kant.KnowledgeCheck;
import it.unimi.xtext.kant.KnowledgeDef;
import it.unimi.xtext.kant.KnowledgeDefListDesctructuringAssignment;
import it.unimi.xtext.kant.KnowledgeDefListDestructuring;
import it.unimi.xtext.kant.KnowledgeDefSetDesctructuringAssignment;
import it.unimi.xtext.kant.KnowledgeDefSetDestructuring;
import it.unimi.xtext.kant.KnowledgeEqualityDef;
import it.unimi.xtext.kant.KnowledgeFromFunction;
import it.unimi.xtext.kant.KnowledgeFromFunctionArg;
import it.unimi.xtext.kant.KnowledgeGenerator;
import it.unimi.xtext.kant.KnowledgeList;
import it.unimi.xtext.kant.KnowledgeRef;
import it.unimi.xtext.kant.KnowledgeSet;
import it.unimi.xtext.kant.KnowledgeSpreading;
import it.unimi.xtext.kant.LinkabilityCheck;
import it.unimi.xtext.kant.Principal;
import it.unimi.xtext.kant.PropertyDef;
import it.unimi.xtext.kant.Protocol;
import it.unimi.xtext.kant.Scenario;
import it.unimi.xtext.kant.ScenarioAlternatives;
import it.unimi.xtext.kant.ScenarioOptional;
import it.unimi.xtext.kant.UniversalIntroduction;
import it.unimi.xtext.services.KantGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class KantSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private KantGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == KantPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case KantPackage.AUTHENTICATION_CHECK:
				sequence_AuthenticationCheck(context, (AuthenticationCheck) semanticObject); 
				return; 
			case KantPackage.COMMUNICATION:
				sequence_Communication(context, (Communication) semanticObject); 
				return; 
			case KantPackage.EQUALITY_CHECK:
				sequence_EqualityCheck(context, (EqualityCheck) semanticObject); 
				return; 
			case KantPackage.FRESHNESS_CHECK:
				sequence_FreshnessCheck(context, (FreshnessCheck) semanticObject); 
				return; 
			case KantPackage.FUNCTION_DEF:
				sequence_FunctionDef(context, (FunctionDef) semanticObject); 
				return; 
			case KantPackage.FUNCTION_INVERSION_DEF:
				sequence_FunctionInversionDef(context, (FunctionInversionDef) semanticObject); 
				return; 
			case KantPackage.FUNCTION_KEY:
				sequence_FunctionKey(context, (FunctionKey) semanticObject); 
				return; 
			case KantPackage.FUNCTION_KEY_ELEMENT:
				sequence_FunctionKeyElement(context, (FunctionKeyElement) semanticObject); 
				return; 
			case KantPackage.FUNCTION_PARAM:
				sequence_FunctionParam(context, (FunctionParam) semanticObject); 
				return; 
			case KantPackage.FUNCTION_RETURN:
				sequence_FunctionReturn(context, (FunctionReturn) semanticObject); 
				return; 
			case KantPackage.FUNCTION_RETURN_ELEMENT:
				sequence_FunctionReturnElement(context, (FunctionReturnElement) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_BASE:
				sequence_KnowledgeBase(context, (KnowledgeBase) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_CHECK:
				sequence_KnowledgeCheck(context, (KnowledgeCheck) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_DEF:
				sequence_KnowledgeDef(context, (KnowledgeDef) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_DEF_LIST_DESCTRUCTURING_ASSIGNMENT:
				sequence_KnowledgeDefListDesctructuringAssignment(context, (KnowledgeDefListDesctructuringAssignment) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_DEF_LIST_DESTRUCTURING:
				if (rule == grammarAccess.getKnowledgeDefDestructuringRule()
						|| rule == grammarAccess.getKnowledgeDefListDestructuringRule()) {
					sequence_KnowledgeDefListDestructuring(context, (KnowledgeDefListDestructuring) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKnowledgeRule()
						|| rule == grammarAccess.getKnowledgeDefRule()) {
					sequence_KnowledgeDef_KnowledgeDefListDestructuring(context, (KnowledgeDefListDestructuring) semanticObject); 
					return; 
				}
				else break;
			case KantPackage.KNOWLEDGE_DEF_SET_DESCTRUCTURING_ASSIGNMENT:
				sequence_KnowledgeDefSetDesctructuringAssignment(context, (KnowledgeDefSetDesctructuringAssignment) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_DEF_SET_DESTRUCTURING:
				if (rule == grammarAccess.getKnowledgeDefDestructuringRule()
						|| rule == grammarAccess.getKnowledgeDefSetDestructuringRule()) {
					sequence_KnowledgeDefSetDestructuring(context, (KnowledgeDefSetDestructuring) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKnowledgeRule()
						|| rule == grammarAccess.getKnowledgeDefRule()) {
					sequence_KnowledgeDef_KnowledgeDefSetDestructuring(context, (KnowledgeDefSetDestructuring) semanticObject); 
					return; 
				}
				else break;
			case KantPackage.KNOWLEDGE_EQUALITY_DEF:
				sequence_KnowledgeEqualityDef(context, (KnowledgeEqualityDef) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_FROM_FUNCTION:
				sequence_KnowledgeFromFunction(context, (KnowledgeFromFunction) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_FROM_FUNCTION_ARG:
				sequence_KnowledgeFromFunctionArg(context, (KnowledgeFromFunctionArg) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_GENERATOR:
				sequence_KnowledgeGenerator(context, (KnowledgeGenerator) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_LIST:
				sequence_KnowledgeList(context, (KnowledgeList) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_REF:
				sequence_KnowledgeRef(context, (KnowledgeRef) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_SET:
				sequence_KnowledgeSet(context, (KnowledgeSet) semanticObject); 
				return; 
			case KantPackage.KNOWLEDGE_SPREADING:
				sequence_KnowledgeSpreading(context, (KnowledgeSpreading) semanticObject); 
				return; 
			case KantPackage.LINKABILITY_CHECK:
				sequence_LinkabilityCheck(context, (LinkabilityCheck) semanticObject); 
				return; 
			case KantPackage.PRINCIPAL:
				sequence_Principal(context, (Principal) semanticObject); 
				return; 
			case KantPackage.PROPERTY_DEF:
				sequence_PropertyDef(context, (PropertyDef) semanticObject); 
				return; 
			case KantPackage.PROTOCOL:
				sequence_Protocol(context, (Protocol) semanticObject); 
				return; 
			case KantPackage.SCENARIO:
				sequence_Scenario(context, (Scenario) semanticObject); 
				return; 
			case KantPackage.SCENARIO_ALTERNATIVES:
				sequence_ScenarioAlternatives(context, (ScenarioAlternatives) semanticObject); 
				return; 
			case KantPackage.SCENARIO_OPTIONAL:
				sequence_ScenarioOptional(context, (ScenarioOptional) semanticObject); 
				return; 
			case KantPackage.UNIVERSAL_INTRODUCTION:
				sequence_UniversalIntroduction(context, (UniversalIntroduction) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns AuthenticationCheck
	 *     Check returns AuthenticationCheck
	 *     AuthenticationCheck returns AuthenticationCheck
	 *
	 * Constraint:
	 *     (principal=ID target=ID knowledge=KnowledgeValue)
	 * </pre>
	 */
	protected void sequence_AuthenticationCheck(ISerializationContext context, AuthenticationCheck semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KantPackage.Literals.AUTHENTICATION_CHECK__PRINCIPAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KantPackage.Literals.AUTHENTICATION_CHECK__PRINCIPAL));
			if (transientValues.isValueTransient(semanticObject, KantPackage.Literals.AUTHENTICATION_CHECK__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KantPackage.Literals.AUTHENTICATION_CHECK__TARGET));
			if (transientValues.isValueTransient(semanticObject, KantPackage.Literals.AUTHENTICATION_CHECK__KNOWLEDGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KantPackage.Literals.AUTHENTICATION_CHECK__KNOWLEDGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAuthenticationCheckAccess().getPrincipalIDTerminalRuleCall_0_0(), semanticObject.getPrincipal());
		feeder.accept(grammarAccess.getAuthenticationCheckAccess().getTargetIDTerminalRuleCall_3_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getAuthenticationCheckAccess().getKnowledgeKnowledgeValueParserRuleCall_5_0(), semanticObject.getKnowledge());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Communication
	 *     Communication returns Communication
	 *
	 * Constraint:
	 *     (from+=ID from+=ID* to+=ID to+=ID* knowledge=Knowledge)
	 * </pre>
	 */
	protected void sequence_Communication(ISerializationContext context, Communication semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns EqualityCheck
	 *     Check returns EqualityCheck
	 *     EqualityCheck returns EqualityCheck
	 *
	 * Constraint:
	 *     (knowledge+=KnowledgeRef knowledge+=KnowledgeRef+ not?='not'?)
	 * </pre>
	 */
	protected void sequence_EqualityCheck(ISerializationContext context, EqualityCheck semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns FreshnessCheck
	 *     Check returns FreshnessCheck
	 *     FreshnessCheck returns FreshnessCheck
	 *
	 * Constraint:
	 *     (knowledge+=KnowledgeRef knowledge+=KnowledgeRef* not?='not'?)
	 * </pre>
	 */
	protected void sequence_FreshnessCheck(ISerializationContext context, FreshnessCheck semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns FunctionDef
	 *     FunctionDef returns FunctionDef
	 *
	 * Constraint:
	 *     (
	 *         intro=UniversalIntroduction? 
	 *         name+=ID 
	 *         (params+=FunctionParam params+=FunctionParam*)? 
	 *         key=FunctionKey? 
	 *         return=FunctionReturn? 
	 *         randomized?='randomized'? 
	 *         ow?='one'?
	 *     )
	 * </pre>
	 */
	protected void sequence_FunctionDef(ISerializationContext context, FunctionDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionInversionDef returns FunctionInversionDef
	 *
	 * Constraint:
	 *     (inverter=ID function=ID)
	 * </pre>
	 */
	protected void sequence_FunctionInversionDef(ISerializationContext context, FunctionInversionDef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KantPackage.Literals.FUNCTION_INVERSION_DEF__INVERTER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KantPackage.Literals.FUNCTION_INVERSION_DEF__INVERTER));
			if (transientValues.isValueTransient(semanticObject, KantPackage.Literals.FUNCTION_INVERSION_DEF__FUNCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KantPackage.Literals.FUNCTION_INVERSION_DEF__FUNCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionInversionDefAccess().getInverterIDTerminalRuleCall_0_0(), semanticObject.getInverter());
		feeder.accept(grammarAccess.getFunctionInversionDefAccess().getFunctionIDTerminalRuleCall_2_0(), semanticObject.getFunction());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionKeyElement returns FunctionKeyElement
	 *
	 * Constraint:
	 *     (name+=ID type=KnowledgeValue?)
	 * </pre>
	 */
	protected void sequence_FunctionKeyElement(ISerializationContext context, FunctionKeyElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionKey returns FunctionKey
	 *
	 * Constraint:
	 *     (elements+=FunctionKeyElement | (elements+=FunctionKeyElement elements+=FunctionKeyElement*))
	 * </pre>
	 */
	protected void sequence_FunctionKey(ISerializationContext context, FunctionKey semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionParam returns FunctionParam
	 *
	 * Constraint:
	 *     (variadic?='...'? name=ID opt?='?'? type=KnowledgeValue?)
	 * </pre>
	 */
	protected void sequence_FunctionParam(ISerializationContext context, FunctionParam semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionReturnElement returns FunctionReturnElement
	 *
	 * Constraint:
	 *     (name+=ID type=KnowledgeValue?)
	 * </pre>
	 */
	protected void sequence_FunctionReturnElement(ISerializationContext context, FunctionReturnElement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     FunctionReturn returns FunctionReturn
	 *
	 * Constraint:
	 *     (elements+=FunctionReturnElement | (elements+=FunctionReturnElement elements+=FunctionReturnElement*))
	 * </pre>
	 */
	protected void sequence_FunctionReturn(ISerializationContext context, FunctionReturn semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns KnowledgeBase
	 *     KnowledgeBase returns KnowledgeBase
	 *
	 * Constraint:
	 *     (shared?='shared'? knowledge=Knowledge)
	 * </pre>
	 */
	protected void sequence_KnowledgeBase(ISerializationContext context, KnowledgeBase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns KnowledgeCheck
	 *     Check returns KnowledgeCheck
	 *     KnowledgeCheck returns KnowledgeCheck
	 *
	 * Constraint:
	 *     (
	 *         here?='here'? 
	 *         only?='only'? 
	 *         target+=ID 
	 *         target+=ID* 
	 *         not?='not'? 
	 *         knowledge=KnowledgeValue
	 *     )
	 * </pre>
	 */
	protected void sequence_KnowledgeCheck(ISerializationContext context, KnowledgeCheck semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     KnowledgeDefListDesctructuringAssignment returns KnowledgeDefListDesctructuringAssignment
	 *
	 * Constraint:
	 *     name=ID?
	 * </pre>
	 */
	protected void sequence_KnowledgeDefListDesctructuringAssignment(ISerializationContext context, KnowledgeDefListDesctructuringAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     KnowledgeDefDestructuring returns KnowledgeDefListDestructuring
	 *     KnowledgeDefListDestructuring returns KnowledgeDefListDestructuring
	 *
	 * Constraint:
	 *     (assignments+=KnowledgeDefListDesctructuringAssignment assignments+=KnowledgeDefListDesctructuringAssignment*)?
	 * </pre>
	 */
	protected void sequence_KnowledgeDefListDestructuring(ISerializationContext context, KnowledgeDefListDestructuring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     KnowledgeDefSetDesctructuringAssignment returns KnowledgeDefSetDesctructuringAssignment
	 *
	 * Constraint:
	 *     (name=ID from=ID?)
	 * </pre>
	 */
	protected void sequence_KnowledgeDefSetDesctructuringAssignment(ISerializationContext context, KnowledgeDefSetDesctructuringAssignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     KnowledgeDefDestructuring returns KnowledgeDefSetDestructuring
	 *     KnowledgeDefSetDestructuring returns KnowledgeDefSetDestructuring
	 *
	 * Constraint:
	 *     (assignments+=KnowledgeDefSetDesctructuringAssignment assignments+=KnowledgeDefSetDesctructuringAssignment*)?
	 * </pre>
	 */
	protected void sequence_KnowledgeDefSetDestructuring(ISerializationContext context, KnowledgeDefSetDestructuring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Knowledge returns KnowledgeDef
	 *     KnowledgeDef returns KnowledgeDef
	 *
	 * Constraint:
	 *     ((name+=ID value=KnowledgeValue) | name+=ID | (name+=ID name+=ID*))
	 * </pre>
	 */
	protected void sequence_KnowledgeDef(ISerializationContext context, KnowledgeDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Knowledge returns KnowledgeDefListDestructuring
	 *     KnowledgeDef returns KnowledgeDefListDestructuring
	 *
	 * Constraint:
	 *     ((assignments+=KnowledgeDefListDesctructuringAssignment assignments+=KnowledgeDefListDesctructuringAssignment*)? value=KnowledgeValue)
	 * </pre>
	 */
	protected void sequence_KnowledgeDef_KnowledgeDefListDestructuring(ISerializationContext context, KnowledgeDefListDestructuring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Knowledge returns KnowledgeDefSetDestructuring
	 *     KnowledgeDef returns KnowledgeDefSetDestructuring
	 *
	 * Constraint:
	 *     ((assignments+=KnowledgeDefSetDesctructuringAssignment assignments+=KnowledgeDefSetDesctructuringAssignment*)? value=KnowledgeValue)
	 * </pre>
	 */
	protected void sequence_KnowledgeDef_KnowledgeDefSetDestructuring(ISerializationContext context, KnowledgeDefSetDestructuring semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     KnowledgeEqualityDef returns KnowledgeEqualityDef
	 *
	 * Constraint:
	 *     (intro=UniversalIntroduction? value=KnowledgeValue target=KnowledgeValue)
	 * </pre>
	 */
	protected void sequence_KnowledgeEqualityDef(ISerializationContext context, KnowledgeEqualityDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     KnowledgeFromFunctionArg returns KnowledgeFromFunctionArg
	 *
	 * Constraint:
	 *     (args+=KnowledgeValue args+=KnowledgeValue*)
	 * </pre>
	 */
	protected void sequence_KnowledgeFromFunctionArg(ISerializationContext context, KnowledgeFromFunctionArg semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Knowledge returns KnowledgeFromFunction
	 *     KnowledgeValue returns KnowledgeFromFunction
	 *     KnowledgeFromFunction returns KnowledgeFromFunction
	 *
	 * Constraint:
	 *     (name=ID args=KnowledgeFromFunctionArg? key=KnowledgeValue?)
	 * </pre>
	 */
	protected void sequence_KnowledgeFromFunction(ISerializationContext context, KnowledgeFromFunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Knowledge returns KnowledgeGenerator
	 *     KnowledgeValue returns KnowledgeGenerator
	 *     KnowledgeGenerator returns KnowledgeGenerator
	 *
	 * Constraint:
	 *     type=STRING
	 * </pre>
	 */
	protected void sequence_KnowledgeGenerator(ISerializationContext context, KnowledgeGenerator semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, KantPackage.Literals.KNOWLEDGE_GENERATOR__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, KantPackage.Literals.KNOWLEDGE_GENERATOR__TYPE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getKnowledgeGeneratorAccess().getTypeSTRINGTerminalRuleCall_1_0(), semanticObject.getType());
		feeder.finish();
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Knowledge returns KnowledgeList
	 *     KnowledgeValue returns KnowledgeList
	 *     KnowledgeList returns KnowledgeList
	 *
	 * Constraint:
	 *     ((values+=KnowledgeValue | values+=KnowledgeSpreading) values+=KnowledgeValue? (values+=KnowledgeSpreading? values+=KnowledgeValue?)*)?
	 * </pre>
	 */
	protected void sequence_KnowledgeList(ISerializationContext context, KnowledgeList semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Knowledge returns KnowledgeRef
	 *     KnowledgeValue returns KnowledgeRef
	 *     KnowledgeRef returns KnowledgeRef
	 *
	 * Constraint:
	 *     (ref=ID access+=ID*)
	 * </pre>
	 */
	protected void sequence_KnowledgeRef(ISerializationContext context, KnowledgeRef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Knowledge returns KnowledgeSet
	 *     KnowledgeValue returns KnowledgeSet
	 *     KnowledgeSet returns KnowledgeSet
	 *
	 * Constraint:
	 *     ((content+=Knowledge | content+=KnowledgeSpreading) content+=Knowledge? (content+=KnowledgeSpreading? content+=Knowledge?)*)?
	 * </pre>
	 */
	protected void sequence_KnowledgeSet(ISerializationContext context, KnowledgeSet semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     KnowledgeSpreading returns KnowledgeSpreading
	 *     KnowledgeFromFunctionArg returns KnowledgeSpreading
	 *
	 * Constraint:
	 *     (ref=KnowledgeRef | ref=KnowledgeSet | ref=KnowledgeList)
	 * </pre>
	 */
	protected void sequence_KnowledgeSpreading(ISerializationContext context, KnowledgeSpreading semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns LinkabilityCheck
	 *     Check returns LinkabilityCheck
	 *     LinkabilityCheck returns LinkabilityCheck
	 *
	 * Constraint:
	 *     (knowledge+=KnowledgeRef knowledge+=KnowledgeRef+ not?='not'?)
	 * </pre>
	 */
	protected void sequence_LinkabilityCheck(ISerializationContext context, LinkabilityCheck semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns Principal
	 *     Principal returns Principal
	 *
	 * Constraint:
	 *     (name+=ID name+=ID* knowledge=Knowledge?)
	 * </pre>
	 */
	protected void sequence_Principal(ISerializationContext context, Principal semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns PropertyDef
	 *     PropertyDef returns PropertyDef
	 *
	 * Constraint:
	 *     (property=KnowledgeEqualityDef | property=FunctionInversionDef)
	 * </pre>
	 */
	protected void sequence_PropertyDef(ISerializationContext context, PropertyDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Protocol returns Protocol
	 *
	 * Constraint:
	 *     elements+=Element+
	 * </pre>
	 */
	protected void sequence_Protocol(ISerializationContext context, Protocol semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns ScenarioAlternatives
	 *     ScenarioBranching returns ScenarioAlternatives
	 *     ScenarioAlternatives returns ScenarioAlternatives
	 *
	 * Constraint:
	 *     (scenario+=Scenario scenario+=Scenario+)
	 * </pre>
	 */
	protected void sequence_ScenarioAlternatives(ISerializationContext context, ScenarioAlternatives semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Element returns ScenarioOptional
	 *     ScenarioBranching returns ScenarioOptional
	 *     ScenarioOptional returns ScenarioOptional
	 *
	 * Constraint:
	 *     scenario+=Scenario
	 * </pre>
	 */
	protected void sequence_ScenarioOptional(ISerializationContext context, ScenarioOptional semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     Scenario returns Scenario
	 *
	 * Constraint:
	 *     (name=STRING? elements+=Element+)
	 * </pre>
	 */
	protected void sequence_Scenario(ISerializationContext context, Scenario semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * <pre>
	 * Contexts:
	 *     UniversalIntroduction returns UniversalIntroduction
	 *
	 * Constraint:
	 *     (args+=ID args+=ID*)
	 * </pre>
	 */
	protected void sequence_UniversalIntroduction(ISerializationContext context, UniversalIntroduction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
